{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Qkmaxware.Parsing is a C# library for writing parsers using parser combinators. Since Parsing is built off of .Net Standard 2.1 , it is compatible with the .Net Framework as well as .Net Core . This site serves as a resource for installing and using the Parsing Library.","title":"Welcome"},{"location":"#welcome","text":"Qkmaxware.Parsing is a C# library for writing parsers using parser combinators. Since Parsing is built off of .Net Standard 2.1 , it is compatible with the .Net Framework as well as .Net Core . This site serves as a resource for installing and using the Parsing Library.","title":"Welcome"},{"location":"installing/","text":"Installation Qkmaxware.Parsing is distributed as a Nuget package via Github's Package Repository . Github Access Token Github requires that all users will need to authenticate with Github in order to download packages. At the time of writing, the process for creating such a token located on docs.github.com . When creating this token make sure that it permissions to read:packages enabled which is required to download github packages. Adding Package Create an empty project or use an existing .Net project dotnet new console Create a new file at the root of the project named nuget.config and paste the following xml into it. Replace %USERNAME% with your Github username and %ACCESS_TOKEN% with the access token that you created previously. <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key=\"qkmaxware\" value=\"https://nuget.pkg.github.com/qkmaxware/index.json\" /> </packageSources> <packageSourceCredentials> <qkmaxware> <add key=\"Username\" value=\"%USERNAME%\" /> <add key=\"ClearTextPassword\" value=\"%ACCESS_TOKEN%\" /> </qkmaxware> </packageSourceCredentials> </configuration> Add the Qkmaxware.Parsing package, make sure to specify Github as the package source dotnet add package Qkmaxware.Parsing --source \"https://nuget.pkg.github.com/qkmaxware/index.json\"","title":"Installation"},{"location":"installing/#installation","text":"Qkmaxware.Parsing is distributed as a Nuget package via Github's Package Repository .","title":"Installation"},{"location":"installing/#github-access-token","text":"Github requires that all users will need to authenticate with Github in order to download packages. At the time of writing, the process for creating such a token located on docs.github.com . When creating this token make sure that it permissions to read:packages enabled which is required to download github packages.","title":"Github Access Token"},{"location":"installing/#adding-package","text":"Create an empty project or use an existing .Net project dotnet new console Create a new file at the root of the project named nuget.config and paste the following xml into it. Replace %USERNAME% with your Github username and %ACCESS_TOKEN% with the access token that you created previously. <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key=\"qkmaxware\" value=\"https://nuget.pkg.github.com/qkmaxware/index.json\" /> </packageSources> <packageSourceCredentials> <qkmaxware> <add key=\"Username\" value=\"%USERNAME%\" /> <add key=\"ClearTextPassword\" value=\"%ACCESS_TOKEN%\" /> </qkmaxware> </packageSourceCredentials> </configuration> Add the Qkmaxware.Parsing package, make sure to specify Github as the package source dotnet add package Qkmaxware.Parsing --source \"https://nuget.pkg.github.com/qkmaxware/index.json\"","title":"Adding Package"},{"location":"introduction/","text":"Introduction Parsers Parsers are functions that can be used to identify specific phrases within input text and return a computer friendly data-structure representing the type of parsed content. Any function matching the following signature can be used as a parser. Result<T> Parser<T>(IInput input); Combinators Combinators are functions that can be used to apply transformations to parsers in order to construct new parsers. Combinators can be stacked to create complicated parsers from simple ones. Any function matching the following signaure can be used as a combinator. Parser<O> Combinator<I,O>(Parser<I> parser) This library implements several default combinators which are applied as extension methods on any compatible parser functions.","title":"Introduction"},{"location":"introduction/#introduction","text":"","title":"Introduction"},{"location":"introduction/#parsers","text":"Parsers are functions that can be used to identify specific phrases within input text and return a computer friendly data-structure representing the type of parsed content. Any function matching the following signature can be used as a parser. Result<T> Parser<T>(IInput input);","title":"Parsers"},{"location":"introduction/#combinators","text":"Combinators are functions that can be used to apply transformations to parsers in order to construct new parsers. Combinators can be stacked to create complicated parsers from simple ones. Any function matching the following signaure can be used as a combinator. Parser<O> Combinator<I,O>(Parser<I> parser) This library implements several default combinators which are applied as extension methods on any compatible parser functions.","title":"Combinators"},{"location":"usage/","text":"Usage Identifying Specific Characters Use Character.Any to create a parser that matches any character in the input stream. Character.Any() Character.Is can be used to create a parser that matches the character provided via the argument. Character.Is('x') Character.IsNot can be used to create a parser matches any character except one provided via the argument. Character.IsNot('u') Character.OneOf can be used to create a parser that matches any of the characters provided via the arguments. Character.OneOf('a', 'b', 'c') Character.IsNotOneOf can be used to create a parser that matches any character except those provided via the arguments. Character.IsNotOneOf('d', 'e', 'f') Character.Letter can be used to match all alphabetical characters. Character.Letter() Character.Digit can be used to match all numeric characters. Character.Digit() Character.LetterOrDigit can be used to match all alphabetical or numeric characters. Character.LetterOrDigit() Character.Whitespace can be used to match any whitespace characters. Character.Whitespace() Identifying Specific Strings Use String.Is to create parsers that match the exact sequence of characters in the string argument. String.Is(\"Dog\") Parsing Common Types This library includes some parsers for commonly used programming concepts. Boolean Boolean parses boolean truthy values from the literal strings \"true\" and \"false\". Literal.Boolean(); Numbers The Whole , Real , and Scientific methods create parsers for parsing numbers from text. Whole parses positive integers including 0. Real parses decimal numbers. Scientific parses numbers in scientific notation where the exponent is provided after the 'e' character. Literal.Whole(); Literal.Real(); Literal.Scientific(); To parse any number the Number method creates a parser that can parse any of the above numerics formats. Literal.Number(); Comments Line comments can be parsed using the Line method. Line comments begin with '//' and end when the line ends. Comment.Line(); Block comments can be parsed using the Block method. Block comments begin with '/*' and ends when a '*/' is found. Comment.Block(); In certain languages, block comments can be nested. The NestedBlock method creates parsers in which block comments can be nested within each other. Comment.NestedBlock(); Sequencing Parsers Parser Order The Then combinator applies two parsers in sequence and keeps the results of the second parser. The Before combinator applies two parsers in sequence and keeps the results of the second combinator. The Between combinator returns the results of the middle parser which is surrounded by two other parsers. Alternatives The Or combinator provides alternative branches. The results of the first parser are used if it exists, otherwise the other parsers are tried until one of them is successful. Repeating Parsers The ZeroOrMore combinator repeats the given parser zero or more times and returns a list with the results of all the parsers. The OneOrMore combinator is the same as the ZeroOrMore combinator except that it requires at least one successful repetition of the parser. Additionally these combinators have a variations ZeroOrMoreSeparatedBy and OneOrMoreSeparatedBy which repeats a parser, but only as long as a separator exists between successive elements. Type Conversion The Map combinator transforms the output of one parser into a different type.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#identifying-specific-characters","text":"Use Character.Any to create a parser that matches any character in the input stream. Character.Any() Character.Is can be used to create a parser that matches the character provided via the argument. Character.Is('x') Character.IsNot can be used to create a parser matches any character except one provided via the argument. Character.IsNot('u') Character.OneOf can be used to create a parser that matches any of the characters provided via the arguments. Character.OneOf('a', 'b', 'c') Character.IsNotOneOf can be used to create a parser that matches any character except those provided via the arguments. Character.IsNotOneOf('d', 'e', 'f') Character.Letter can be used to match all alphabetical characters. Character.Letter() Character.Digit can be used to match all numeric characters. Character.Digit() Character.LetterOrDigit can be used to match all alphabetical or numeric characters. Character.LetterOrDigit() Character.Whitespace can be used to match any whitespace characters. Character.Whitespace()","title":"Identifying Specific Characters"},{"location":"usage/#identifying-specific-strings","text":"Use String.Is to create parsers that match the exact sequence of characters in the string argument. String.Is(\"Dog\")","title":"Identifying Specific Strings"},{"location":"usage/#parsing-common-types","text":"This library includes some parsers for commonly used programming concepts.","title":"Parsing Common Types"},{"location":"usage/#boolean","text":"Boolean parses boolean truthy values from the literal strings \"true\" and \"false\". Literal.Boolean();","title":"Boolean"},{"location":"usage/#numbers","text":"The Whole , Real , and Scientific methods create parsers for parsing numbers from text. Whole parses positive integers including 0. Real parses decimal numbers. Scientific parses numbers in scientific notation where the exponent is provided after the 'e' character. Literal.Whole(); Literal.Real(); Literal.Scientific(); To parse any number the Number method creates a parser that can parse any of the above numerics formats. Literal.Number();","title":"Numbers"},{"location":"usage/#comments","text":"Line comments can be parsed using the Line method. Line comments begin with '//' and end when the line ends. Comment.Line(); Block comments can be parsed using the Block method. Block comments begin with '/*' and ends when a '*/' is found. Comment.Block(); In certain languages, block comments can be nested. The NestedBlock method creates parsers in which block comments can be nested within each other. Comment.NestedBlock();","title":"Comments"},{"location":"usage/#sequencing-parsers","text":"","title":"Sequencing Parsers"},{"location":"usage/#parser-order","text":"The Then combinator applies two parsers in sequence and keeps the results of the second parser. The Before combinator applies two parsers in sequence and keeps the results of the second combinator. The Between combinator returns the results of the middle parser which is surrounded by two other parsers.","title":"Parser Order"},{"location":"usage/#alternatives","text":"The Or combinator provides alternative branches. The results of the first parser are used if it exists, otherwise the other parsers are tried until one of them is successful.","title":"Alternatives"},{"location":"usage/#repeating-parsers","text":"The ZeroOrMore combinator repeats the given parser zero or more times and returns a list with the results of all the parsers. The OneOrMore combinator is the same as the ZeroOrMore combinator except that it requires at least one successful repetition of the parser. Additionally these combinators have a variations ZeroOrMoreSeparatedBy and OneOrMoreSeparatedBy which repeats a parser, but only as long as a separator exists between successive elements.","title":"Repeating Parsers"},{"location":"usage/#type-conversion","text":"The Map combinator transforms the output of one parser into a different type.","title":"Type Conversion"}]}